; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -D__FPU_PRESENT=1 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;418    
;;;419    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;420    {
;;;421    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;422    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;423    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;424    	
;;;425    }
;;;426    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.PDMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  PDMA_IRQHandler PROC
;;;185    
;;;186    void PDMA_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;187    {
;;;188        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
000002  4c26              LDR      r4,|L3.156|
000004  6820              LDR      r0,[r4,#0]
;;;189    
;;;190        if(status & PDMA_INTSTS_REQTOF1_Msk)	//(1 << (PDMA_INTSTS_REQTOF1_Pos + UART_RX_PDMA_CH) /* Request Time-out */
000006  0581              LSLS     r1,r0,#22
000008  d523              BPL      |L3.82|
;;;191        {
;;;192    		PDMA_SetTimeOut(PDMA,PDMAchannel_TIMER_EXT, 0, 0);
00000a  4d25              LDR      r5,|L3.160|
00000c  2300              MOVS     r3,#0
00000e  461a              MOV      r2,r3
000010  2101              MOVS     r1,#1
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       PDMA_SetTimeOut
;;;193    	
;;;194            /* Clear PDMA timeout interrupt flag */
;;;195            PDMA_CLR_TMOUT_FLAG(PDMA, PDMAchannel_TIMER_EXT);
000018  1560              ASRS     r0,r4,#21
00001a  6020              STR      r0,[r4,#0]
;;;196    
;;;197    		PDMA_SetTimeOut(PDMA,PDMAchannel_TIMER_EXT, TRUE, PDMATIMEOUT(1));
00001c  f7fffffe          BL       CLK_GetCPUFreq
000020  0bc0              LSRS     r0,r0,#15
000022  f44f717a          MOV      r1,#0x3e8
000026  fbb0f3f1          UDIV     r3,r0,r1
00002a  2201              MOVS     r2,#1
00002c  4611              MOV      r1,r2
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       PDMA_SetTimeOut
;;;198            /* Disable and enable timeout function to restart the timeout counter */
;;;199    		PDMA_DisableTimeout(PDMA,(1 << PDMAchannel_TIMER_EXT) );
000034  2102              MOVS     r1,#2
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       PDMA_DisableTimeout
;;;200    		PDMA_EnableTimeout(PDMA,(1 << PDMAchannel_TIMER_EXT) );
00003c  2102              MOVS     r1,#2
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       PDMA_EnableTimeout
;;;201    		
;;;202            /* Set transfer count and trigger again */
;;;203            PDMA_SetTransferCnt(PDMA, PDMAchannel_TIMER_EXT, PDMA_WIDTH_32, dPDMA_TEST_LENGTH);
000044  2301              MOVS     r3,#1
000046  035a              LSLS     r2,r3,#13
000048  4619              MOV      r1,r3
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       PDMA_SetTransferCnt
;;;204            /* Get the latest status for SPI PDMA again */
;;;205            status = PDMA_GET_INT_STATUS(PDMA);
000050  6820              LDR      r0,[r4,#0]
                  |L3.82|
000052  f04f0502          MOV      r5,#2                 ;199
;;;206        }
;;;207    
;;;208    
;;;209        if (status & PDMA_INTSTS_ABTIF_Msk)   /* abort */
000056  07c1              LSLS     r1,r0,#31
000058  d009              BEQ      |L3.110|
;;;210        {
;;;211            /* Check if channel 1 has abort error */
;;;212            if (PDMA_GET_ABORT_STS(PDMA) & PDMA_ABTSTS_ABTIF1_Msk)
00005a  4c10              LDR      r4,|L3.156|
00005c  1d24              ADDS     r4,r4,#4
00005e  6820              LDR      r0,[r4,#0]
000060  0780              LSLS     r0,r0,#30
000062  d502              BPL      |L3.106|
;;;213            {
;;;214    			//abort
;;;215    			printf("abort\r\n");
000064  a00f              ADR      r0,|L3.164|
000066  f7fffffe          BL       __2printf
                  |L3.106|
;;;216            }
;;;217    
;;;218            /* Clear abort flag of channel 1 */
;;;219            PDMA_CLR_ABORT_FLAG(PDMA, PDMA_ABTSTS_ABTIF1_Msk);
00006a  6025              STR      r5,[r4,#0]
;;;220        }
;;;221        else if (status & PDMA_INTSTS_TDIF_Msk)     /* done */
;;;222        {
;;;223            /* Check transmission of channel 1 has been transfer done */
;;;224            if (PDMA_GET_TD_STS(PDMA) & PDMA_TDSTS_TDIF1_Msk)
;;;225            {
;;;226    			//done
;;;227    			TIMER_ClearCaptureIntFlag(TIMER0);
;;;228    //			TIMER_Stop(TIMER0);
;;;229    			
;;;230    			PDMA_TimerCapture_Process();
;;;231    			LED_R = ~LED_R;
;;;232            }
;;;233    
;;;234            /* Clear transfer done flag of channel 1 */
;;;235            PDMA_CLR_TD_FLAG(PDMA, PDMA_TDSTS_TDIF1_Msk);
;;;236        }
;;;237        else
;;;238            printf("unknown interrupt !!\n");
;;;239    }
00006c  bd70              POP      {r4-r6,pc}
                  |L3.110|
00006e  0780              LSLS     r0,r0,#30             ;221
000070  d50e              BPL      |L3.144|
000072  4c0a              LDR      r4,|L3.156|
000074  3408              ADDS     r4,r4,#8              ;224
000076  6820              LDR      r0,[r4,#0]            ;224
000078  0780              LSLS     r0,r0,#30             ;224
00007a  d5f6              BPL      |L3.106|
00007c  490b              LDR      r1,|L3.172|
00007e  2001              MOVS     r0,#1                 ;224
000080  6188              STR      r0,[r1,#0x18]         ;224
000082  f7fffffe          BL       PDMA_TimerCapture_Process
000086  480a              LDR      r0,|L3.176|
000088  6801              LDR      r1,[r0,#0]            ;231
00008a  43c9              MVNS     r1,r1                 ;231
00008c  6001              STR      r1,[r0,#0]            ;231
00008e  e7ec              B        |L3.106|
                  |L3.144|
000090  e8bd4070          POP      {r4-r6,lr}            ;238
000094  a007              ADR      r0,|L3.180|
000096  f7ffbffe          B.W      __2printf
;;;240    
                          ENDP

00009a  0000              DCW      0x0000
                  |L3.156|
                          DCD      0x4000841c
                  |L3.160|
                          DCD      0x40008000
                  |L3.164|
0000a4  61626f72          DCB      "abort\r\n",0
0000a8  740d0a00
                  |L3.172|
                          DCD      0x40050000
                  |L3.176|
                          DCD      0x400049c0
                  |L3.180|
0000b4  756e6b6e          DCB      "unknown interrupt !!\n",0
0000b8  6f776e20
0000bc  696e7465
0000c0  72727570
0000c4  74202121
0000c8  0a00    
0000ca  00                DCB      0
0000cb  00                DCB      0

                          AREA ||i.PDMA_TimerCapture_Init||, CODE, READONLY, ALIGN=2

                  PDMA_TimerCapture_Init PROC
;;;93     
;;;94     void PDMA_TimerCapture_Init(void)	//PB15 : TM0_EXT 
000000  b57c              PUSH     {r2-r6,lr}
;;;95     {
;;;96         /* Enable Timer0 external capture function */
;;;97         TIMER_Open(TIMER0, TIMER_CONTINUOUS_MODE, 1);
000002  4c31              LDR      r4,|L4.200|
000004  2201              MOVS     r2,#1
000006  f04f51c0          MOV      r1,#0x18000000
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       TIMER_Open
;;;98         TIMER_SET_PRESCALE_VALUE(TIMER0, TIMER_PSC);
000010  6820              LDR      r0,[r4,#0]
000012  f04000ff          ORR      r0,r0,#0xff
000016  6020              STR      r0,[r4,#0]
;;;99         TIMER_SET_CMP_VALUE(TIMER0, 0xFFFFFF);
000018  f06f407f          MVN      r0,#0xff000000
00001c  6060              STR      r0,[r4,#4]
;;;100        TIMER_EnableCapture(TIMER0, TIMER_CAPTURE_FREE_COUNTING_MODE, TIMER_CAPTURE_EVENT_FALLING);
00001e  2200              MOVS     r2,#0
000020  4611              MOV      r1,r2
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       TIMER_EnableCapture
;;;101        TIMER_SetTriggerSource(TIMER0, TIMER_TRGSRC_CAPTURE_EVENT);
000028  2101              MOVS     r1,#1
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       TIMER_SetTriggerSource
;;;102        TIMER_SetTriggerTarget(TIMER0, TIMER_TRG_TO_PDMA);
000030  2110              MOVS     r1,#0x10
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       TIMER_SetTriggerTarget
;;;103    
;;;104    	SYS_ResetModule(PDMA_RST);
000038  2002              MOVS     r0,#2
00003a  f7fffffe          BL       SYS_ResetModule
;;;105    
;;;106        /* Open Channel 1 */
;;;107        PDMA_Open(PDMA, 1 << PDMAchannel_TIMER_EXT);
00003e  4e23              LDR      r6,|L4.204|
000040  2102              MOVS     r1,#2
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       PDMA_Open
;;;108        /* Transfer count is PDMA_TEST_LENGTH, transfer width is 8 bits(one byte) */
;;;109        PDMA_SetTransferCnt(PDMA, PDMAchannel_TIMER_EXT, PDMA_WIDTH_32, dPDMA_TEST_LENGTH);
000048  2301              MOVS     r3,#1
00004a  035a              LSLS     r2,r3,#13
00004c  4619              MOV      r1,r3
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       PDMA_SetTransferCnt
;;;110        /* Set source address is au8SrcArray, Source increment size is 8 bits(one byte), destination address is PA->DOUT (no increment)*/
;;;111        PDMA_SetTransferAddr(PDMA, PDMAchannel_TIMER_EXT, (uint32_t) &(TIMER0->CAP), PDMA_SAR_FIX, (uint32_t)g_au32CAPValue, PDMA_DAR_INC);
000054  2500              MOVS     r5,#0
000056  481e              LDR      r0,|L4.208|
000058  e9cd0500          STRD     r0,r5,[sp,#0]
00005c  4a1a              LDR      r2,|L4.200|
00005e  f44f7340          MOV      r3,#0x300
000062  3210              ADDS     r2,r2,#0x10
000064  2101              MOVS     r1,#1
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       PDMA_SetTransferAddr
;;;112        /* Request source is timer 1 */
;;;113        PDMA_SetTransferMode(PDMA, PDMAchannel_TIMER_EXT, PDMA_TMR0, FALSE,(uint32_t) NULL);
00006c  2300              MOVS     r3,#0
00006e  222e              MOVS     r2,#0x2e
000070  2101              MOVS     r1,#1
000072  4630              MOV      r0,r6
000074  9500              STR      r5,[sp,#0]
000076  f7fffffe          BL       PDMA_SetTransferMode
;;;114        /* Transfer type is burst transfer and burst size is 4 */
;;;115        PDMA_SetBurstType(PDMA, PDMAchannel_TIMER_EXT, PDMA_REQ_BURST,(uint32_t) PDMA_BURST_128);
00007a  2300              MOVS     r3,#0
00007c  461a              MOV      r2,r3
00007e  2101              MOVS     r1,#1
000080  4630              MOV      r0,r6
000082  f7fffffe          BL       PDMA_SetBurstType
;;;116    
;;;117    	PDMA_SetTimeOut(PDMA,PDMAchannel_TIMER_EXT, TRUE, PDMATIMEOUT(1));
000086  f7fffffe          BL       CLK_GetCPUFreq
00008a  0bc0              LSRS     r0,r0,#15
00008c  f44f717a          MOV      r1,#0x3e8
000090  fbb0f3f1          UDIV     r3,r0,r1
000094  2201              MOVS     r2,#1
000096  4611              MOV      r1,r2
000098  4630              MOV      r0,r6
00009a  f7fffffe          BL       PDMA_SetTimeOut
;;;118    	PDMA_EnableTimeout(PDMA,(1 << PDMAchannel_TIMER_EXT));
00009e  2102              MOVS     r1,#2
0000a0  4630              MOV      r0,r6
0000a2  f7fffffe          BL       PDMA_EnableTimeout
;;;119    
;;;120        /* Enable interrupt */
;;;121        PDMA_EnableInt(PDMA, PDMAchannel_TIMER_EXT, PDMA_INT_TRANS_DONE);
0000a6  2200              MOVS     r2,#0
0000a8  2101              MOVS     r1,#1
0000aa  4630              MOV      r0,r6
0000ac  f7fffffe          BL       PDMA_EnableInt
;;;122        /* Enable NVIC for PDMA */
;;;123        NVIC_EnableIRQ(PDMA_IRQn);
0000b0  2028              MOVS     r0,#0x28
0000b2  f7fffffe          BL       NVIC_EnableIRQ
0000b6  6820              LDR      r0,[r4,#0]
0000b8  f0404080          ORR      r0,r0,#0x40000000
0000bc  6020              STR      r0,[r4,#0]
;;;124    
;;;125        TIMER_Start(TIMER0);
;;;126    
;;;127    	PDMA_TimerCapture_Start();
0000be  e8bd407c          POP      {r2-r6,lr}
0000c2  f7ffbffe          B.W      PDMA_TimerCapture_Start
;;;128    	
;;;129    }
;;;130    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L4.200|
                          DCD      0x40050000
                  |L4.204|
                          DCD      0x40008000
                  |L4.208|
                          DCD      ||area_number.19||+0x4

                          AREA ||i.PDMA_TimerCapture_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_f
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_fp_dec
                  PDMA_TimerCapture_Process PROC
;;;131    
;;;132    void PDMA_TimerCapture_Process(void)
000000  b530              PUSH     {r4,r5,lr}
;;;133    {
000002  ed2d8b02          VPUSH    {d8}
000006  b085              SUB      sp,sp,#0x14
;;;134    //    uint32_t u32InitCount = 0;	
;;;135    //	uint16_t i = 0;
;;;136    
;;;137        volatile uint32_t u32CAPDiff = 0;
000008  2000              MOVS     r0,#0
;;;138        volatile uint32_t clock = 0;
;;;139        volatile uint32_t inputclock = 0;		
;;;140    
;;;141    	static uint32_t u32Temp = 0;
;;;142    	
;;;143    	#if defined (USE_INT)
;;;144        uint32_t Freq = 0;
;;;145    	#elif defined (USE_FLOAT)
;;;146        double Freq = 0;
;;;147    	#endif
;;;148    
;;;149    	#if 0	//debug
;;;150    	printf("\r\n");
;;;151    	for ( i = 0 ; i < dPDMA_TEST_LENGTH; i++)
;;;152    	{
;;;153    		printf("%8d , ",g_au32CAPValue[i]);
;;;154    	}
;;;155    	printf("\r\n");
;;;156    	#endif
;;;157    
;;;158    	
;;;159        u32CAPDiff = g_au32CAPValue[0] - u32Temp;
00000a  4d19              LDR      r5,|L5.112|
00000c  9002              STR      r0,[sp,#8]            ;139
00000e  9003              STR      r0,[sp,#0xc]
000010  1f2c              SUBS     r4,r5,#4
000012  6828              LDR      r0,[r5,#0]  ; g_au32CAPValue
000014  68e1              LDR      r1,[r4,#0xc]  ; u32Temp
000016  1a40              SUBS     r0,r0,r1
;;;160    
;;;161    	//Timer input clock or event source is divided by (PSC+1) before it is fed to the timer up counter
;;;162    	inputclock = TIMER_GetModuleClock(TIMER0);
000018  9004              STR      r0,[sp,#0x10]
00001a  4816              LDR      r0,|L5.116|
00001c  f7fffffe          BL       TIMER_GetModuleClock
;;;163    	clock = (inputclock / (TIMER_PSC + 1));
000020  9003              STR      r0,[sp,#0xc]
000022  0a00              LSRS     r0,r0,#8
;;;164    	LED_Y = ~LED_Y;
000024  9002              STR      r0,[sp,#8]
000026  4814              LDR      r0,|L5.120|
000028  6801              LDR      r1,[r0,#0]
00002a  43c9              MVNS     r1,r1
00002c  6001              STR      r1,[r0,#0]
;;;165    
;;;166    
;;;167    	if (g_au32CAPValue[0] > u32Temp)
00002e  6828              LDR      r0,[r5,#0]  ; g_au32CAPValue
000030  68e1              LDR      r1,[r4,#0xc]  ; u32Temp
000032  4288              CMP      r0,r1
000034  d913              BLS      |L5.94|
;;;168    	{
;;;169    		#if defined (USE_INT)
;;;170    		Freq = (clock/u32CAPDiff);		
;;;171    		printf("clock : %6d (counter:%5d) , Diff: %9d. Freq: %6d Hz\r\n",clock,counter_target,u32CAPDiff, Freq);
;;;172    		
;;;173    		#elif defined (USE_FLOAT) 
;;;174    		Freq = ((double )clock/(double )u32CAPDiff);		
000036  9804              LDR      r0,[sp,#0x10]
000038  f7fffffe          BL       __aeabi_ui2d
00003c  ec410b18          VMOV     d8,r0,r1
000040  9802              LDR      r0,[sp,#8]
000042  f7fffffe          BL       __aeabi_ui2d
000046  ec532b18          VMOV     r2,r3,d8
00004a  f7fffffe          BL       __aeabi_ddiv
00004e  e9cd0100          STRD     r0,r1,[sp,#0]
;;;175    		printf("clock : %6d (counter:%5d) , Diff: %9d. Freq: %.6f Hz\r\n",clock,counter_target,u32CAPDiff, Freq);
000052  9b04              LDR      r3,[sp,#0x10]
000054  68a2              LDR      r2,[r4,#8]  ; counter_target
000056  a009              ADR      r0,|L5.124|
000058  9902              LDR      r1,[sp,#8]
00005a  f7fffffe          BL       __2printf
                  |L5.94|
;;;176    		
;;;177    		#endif
;;;178    	}
;;;179    
;;;180    	u32Temp = g_au32CAPValue[0];
00005e  6828              LDR      r0,[r5,#0]  ; g_au32CAPValue
;;;181    
;;;182    
;;;183    	PDMA_TimerCapture_Start();//PDMA_TimerCapture_Init();
000060  60e0              STR      r0,[r4,#0xc]  ; u32Temp
000062  b005              ADD      sp,sp,#0x14
000064  ecbd8b02          VPOP     {d8}
000068  e8bd4030          POP      {r4,r5,lr}
00006c  f7ffbffe          B.W      PDMA_TimerCapture_Start
;;;184    }
;;;185    
                          ENDP

                  |L5.112|
                          DCD      ||area_number.19||+0x4
                  |L5.116|
                          DCD      0x40050000
                  |L5.120|
                          DCD      0x400049c4
                  |L5.124|
00007c  636c6f63          DCB      "clock : %6d (counter:%5d) , Diff: %9d. Freq: %.6f Hz\r\n"
000080  6b203a20
000084  25366420
000088  28636f75
00008c  6e746572
000090  3a253564
000094  29202c20
000098  44696666
00009c  3a202539
0000a0  642e2046
0000a4  7265713a
0000a8  20252e36
0000ac  6620487a
0000b0  0d0a    
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.PDMA_TimerCapture_Start||, CODE, READONLY, ALIGN=2

                  PDMA_TimerCapture_Start PROC
;;;74     
;;;75     void PDMA_TimerCapture_Start(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;76     {
;;;77         /* Transfer count is PDMA_TEST_LENGTH, transfer width is 8 bits(one byte) */
;;;78         PDMA_SetTransferCnt(PDMA, PDMAchannel_TIMER_EXT, PDMA_WIDTH_32, dPDMA_TEST_LENGTH);
000002  2301              MOVS     r3,#1
000004  4d10              LDR      r5,|L6.72|
000006  035a              LSLS     r2,r3,#13
000008  4619              MOV      r1,r3
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       PDMA_SetTransferCnt
;;;79         /* Set source address is au8SrcArray, Source increment size is 8 bits(one byte), destination address is PA->DOUT (no increment)*/
;;;80         PDMA_SetTransferAddr(PDMA, PDMAchannel_TIMER_EXT, (uint32_t) &(TIMER0->CAP), PDMA_SAR_FIX, (uint32_t)g_au32CAPValue, PDMA_DAR_INC);
000010  2400              MOVS     r4,#0
000012  490e              LDR      r1,|L6.76|
000014  e9cd1400          STRD     r1,r4,[sp,#0]
000018  f44f7340          MOV      r3,#0x300
00001c  4a0c              LDR      r2,|L6.80|
00001e  2101              MOVS     r1,#1
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       PDMA_SetTransferAddr
;;;81         /* Request source is timer 1 */
;;;82         PDMA_SetTransferMode(PDMA, PDMAchannel_TIMER_EXT, PDMA_TMR0, FALSE,(uint32_t) NULL);
000026  2300              MOVS     r3,#0
000028  222e              MOVS     r2,#0x2e
00002a  2101              MOVS     r1,#1
00002c  4628              MOV      r0,r5
00002e  9400              STR      r4,[sp,#0]
000030  f7fffffe          BL       PDMA_SetTransferMode
;;;83         /* Transfer type is burst transfer and burst size is 4 */
;;;84         PDMA_SetBurstType(PDMA, PDMAchannel_TIMER_EXT, PDMA_REQ_SINGLE,(uint32_t) PDMA_BURST_128);
000034  b002              ADD      sp,sp,#8
000036  4628              MOV      r0,r5
000038  e8bd4070          POP      {r4-r6,lr}
00003c  2300              MOVS     r3,#0
00003e  2204              MOVS     r2,#4
000040  2101              MOVS     r1,#1
000042  f7ffbffe          B.W      PDMA_SetBurstType
;;;85     }
;;;86     
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
                          DCD      0x40008000
                  |L6.76|
                          DCD      ||area_number.19||+0x4
                  |L6.80|
                          DCD      0x40050010

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;426    
;;;427    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L7.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L7.10|
;;;428    {
;;;429        /*---------------------------------------------------------------------------------------------------------*/
;;;430        /* Init System Clock                                                                                       */
;;;431        /*---------------------------------------------------------------------------------------------------------*/
;;;432        /* Unlock protected registers */
;;;433        SYS_UnlockReg();
;;;434    
;;;435        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;436        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2040          MOV      r0,#0x40004000
000022  f8d01140          LDR      r1,[r0,#0x140]
000026  f02101f0          BIC      r1,r1,#0xf0
00002a  f8c01140          STR      r1,[r0,#0x140]
;;;437    
;;;438        /* Enable External XTAL (4~24 MHz) */
;;;439        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;440    
;;;441        /* Waiting for 12MHz clock ready */
;;;442        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       CLK_WaitClockReady
;;;443    
;;;444        /* Set core clock as PLL_CLOCK from PLL */
;;;445        CLK_SetCoreClock(FREQ_192MHZ);
00003a  481d              LDR      r0,|L7.176|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;446        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;447        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;448    
;;;449        /* Enable UART clock */
;;;450        CLK_EnableModuleClock(UART0_MODULE);
000046  4d1b              LDR      r5,|L7.180|
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;451    
;;;452        /* Select UART clock source from HXT */
;;;453        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       CLK_SetModuleClock
;;;454    
;;;455        /* Enable PDMA module clock */
;;;456        CLK_EnableModuleClock(PDMA_MODULE);
000058  2001              MOVS     r0,#1
00005a  f7fffffe          BL       CLK_EnableModuleClock
;;;457    
;;;458        CLK_EnableModuleClock(TMR3_MODULE);
00005e  4d16              LDR      r5,|L7.184|
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       CLK_EnableModuleClock
;;;459        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
000066  2200              MOVS     r2,#0
000068  f44f1100          MOV      r1,#0x200000
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       CLK_SetModuleClock
;;;460    
;;;461        CLK_EnableModuleClock(TMR0_MODULE);
000072  4d12              LDR      r5,|L7.188|
000074  4628              MOV      r0,r5
000076  f7fffffe          BL       CLK_EnableModuleClock
;;;462        CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
00007a  2200              MOVS     r2,#0
00007c  f44f7100          MOV      r1,#0x200
000080  4628              MOV      r0,r5
000082  f7fffffe          BL       CLK_SetModuleClock
;;;463    	
;;;464        /* Update System Core Clock */
;;;465        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;466        SystemCoreClockUpdate();
000086  f7fffffe          BL       SystemCoreClockUpdate
;;;467    
;;;468        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;469        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
00008a  6be0              LDR      r0,[r4,#0x3c]
00008c  f420007f          BIC      r0,r0,#0xff0000
000090  63e0              STR      r0,[r4,#0x3c]
;;;470        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000092  6be0              LDR      r0,[r4,#0x3c]
000094  f44000cc          ORR      r0,r0,#0x660000
000098  63e0              STR      r0,[r4,#0x3c]
;;;471    
;;;472    	/*----------------------------------------------------*/
;;;473        /* Set multi-function pin for Timer0 external capture pin */
;;;474        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB15MFP_Msk)) \
00009a  6be0              LDR      r0,[r4,#0x3c]
00009c  f0204070          BIC      r0,r0,#0xf0000000
0000a0  f0404050          ORR      r0,r0,#0xd0000000
0000a4  63e0              STR      r0,[r4,#0x3c]
0000a6  2000              MOVS     r0,#0
0000a8  f8c40100          STR      r0,[r4,#0x100]
;;;475                        | SYS_GPB_MFPH_PB15MFP_TM0_EXT;
;;;476    	
;;;477        /* Lock protected registers */
;;;478        SYS_LockReg();
;;;479    }
0000ac  bd70              POP      {r4-r6,pc}
;;;480    /*
                          ENDP

0000ae  0000              DCW      0x0000
                  |L7.176|
                          DCD      0x0b71b000
                  |L7.180|
                          DCD      0x57803d10
                  |L7.184|
                          DCD      0x5f400005
                  |L7.188|
                          DCD      0x5e800002

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;264    
;;;265    void TIMER3_Init(void)		// use 100 us timer
000000  b510              PUSH     {r4,lr}
;;;266    {
;;;267        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 10000);
000002  4c0a              LDR      r4,|L8.44|
000004  f2427210          MOV      r2,#0x2710
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;268        TIMER_EnableInt(TIMER3);
;;;269        NVIC_EnableIRQ(TMR3_IRQn);	
00001a  2023              MOVS     r0,#0x23
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;270        TIMER_Start(TIMER3);
;;;271    }
000028  bd10              POP      {r4,pc}
;;;272    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40051100

                          AREA ||i.TMR0_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler PROC
;;;240    
;;;241    void TMR0_IRQHandler(void)
000000  4802              LDR      r0,|L9.12|
000002  6981              LDR      r1,[r0,#0x18]
;;;242    {
;;;243        if(TIMER_GetCaptureIntFlag(TIMER0) == 1)
000004  2901              CMP      r1,#1
000006  d100              BNE      |L9.10|
000008  6181              STR      r1,[r0,#0x18]         ;242
                  |L9.10|
;;;244        {
;;;245            /* Clear Timer0 capture trigger interrupt flag */
;;;246            TIMER_ClearCaptureIntFlag(TIMER0);
;;;247        }
;;;248    }
00000a  4770              BX       lr
;;;249    void TMR3_IRQHandler(void)
                          ENDP

                  |L9.12|
                          DCD      0x40050000

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR3_IRQHandler PROC
;;;248    }
;;;249    void TMR3_IRQHandler(void)
000000  480b              LDR      r0,|L10.48|
000002  6881              LDR      r1,[r0,#8]
000004  f3c10100          UBFX     r1,r1,#0,#1
;;;250    {
000008  2900              CMP      r1,#0
00000a  d010              BEQ      |L10.46|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;251    	static uint32_t CNT = 0;
;;;252    
;;;253        if(TIMER_GetIntFlag(TIMER3) == 1)
;;;254        {
;;;255            TIMER_ClearIntFlag(TIMER3);
;;;256    
;;;257    		if (CNT++ >= (counter_target >> 1))
000010  4908              LDR      r1,|L10.52|
000012  6908              LDR      r0,[r1,#0x10]  ; CNT
000014  1c42              ADDS     r2,r0,#1
000016  610a              STR      r2,[r1,#0x10]  ; CNT
000018  688a              LDR      r2,[r1,#8]  ; counter_target
00001a  ebb00f52          CMP      r0,r2,LSR #1
00001e  d306              BCC      |L10.46|
;;;258    		{		
;;;259    			CNT = 0;
000020  2000              MOVS     r0,#0
;;;260    			LED_G ^= 1;
000022  6108              STR      r0,[r1,#0x10]  ; CNT
000024  4804              LDR      r0,|L10.56|
000026  6801              LDR      r1,[r0,#0]
000028  f0810101          EOR      r1,r1,#1
00002c  6001              STR      r1,[r0,#0]
                  |L10.46|
;;;261    		}					
;;;262        }
;;;263    }
00002e  4770              BX       lr
;;;264    
                          ENDP

                  |L10.48|
                          DCD      0x40051100
                  |L10.52|
                          DCD      ||area_number.19||
                  |L10.56|
                          DCD      0x400049c8

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  UART0_IRQHandler PROC
;;;320    
;;;321    void UART0_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;322    {
;;;323    	uint8_t i;
;;;324    	static uint16_t u16UART_RX_Buffer_Index = 0;
;;;325    
;;;326        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk))    
000002  4d22              LDR      r5,|L11.140|
000004  69e8              LDR      r0,[r5,#0x1c]
;;;327        {
;;;328            /* UART receive data available flag */
;;;329            
;;;330            /* Record RDA interrupt trigger times */
;;;331            uart0Dev.RDA_Trigger_Cnt++;
000006  4c22              LDR      r4,|L11.144|
;;;332            
;;;333            /* Move the data from Rx FIFO to sw buffer (RAM). */
;;;334            /* Every time leave 1 byte data in FIFO for Rx timeout */
;;;335            for(i = 0 ; i < (FIFO_THRESHOLD - 1) ; i++)
;;;336            {
;;;337                uart0Dev.RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
000008  4a22              LDR      r2,|L11.148|
00000a  05c0              LSLS     r0,r0,#23             ;326
00000c  f04f0300          MOV      r3,#0                 ;326
000010  d513              BPL      |L11.58|
000012  f8940102          LDRB     r0,[r4,#0x102]        ;331  ; uart0Dev
000016  1c40              ADDS     r0,r0,#1              ;331
000018  f8840102          STRB     r0,[r4,#0x102]        ;331
00001c  2100              MOVS     r1,#0                 ;335
                  |L11.30|
00001e  682e              LDR      r6,[r5,#0]
000020  8810              LDRH     r0,[r2,#0]  ; u16UART_RX_Buffer_Index
000022  5426              STRB     r6,[r4,r0]
000024  1c40              ADDS     r0,r0,#1
;;;338                u16UART_RX_Buffer_Index ++;
000026  b280              UXTH     r0,r0
000028  8010              STRH     r0,[r2,#0]
;;;339    
;;;340                if (u16UART_RX_Buffer_Index >= RX_BUFFER_SIZE) 
00002a  28ff              CMP      r0,#0xff
00002c  d900              BLS      |L11.48|
;;;341                    u16UART_RX_Buffer_Index = 0;
00002e  8013              STRH     r3,[r2,#0]
                  |L11.48|
000030  1c49              ADDS     r1,r1,#1
000032  b2c9              UXTB     r1,r1                 ;335
000034  2903              CMP      r1,#3                 ;335
000036  d3f2              BCC      |L11.30|
                  |L11.56|
;;;342            }
;;;343        }
;;;344        else if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RXTOINT_Msk)) 
;;;345        {
;;;346            /* When Rx timeout flag is set to 1, it means there is no data needs to be transmitted. */
;;;347    
;;;348            /* Record Timeout times */
;;;349            uart0Dev.RXTO_Trigger_Cnt++;
;;;350    
;;;351            /* Move the last data from Rx FIFO to sw buffer. */
;;;352            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;353            {
;;;354                uart0Dev.RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
;;;355                u16UART_RX_Buffer_Index ++;
;;;356            }
;;;357    
;;;358            /* Clear UART RX parameter */
;;;359            UART_DISABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
;;;360            u16UART_RX_Buffer_Index = 0;
;;;361    
;;;362    //		set_flag(flag_UART0_Received_Data , ENABLE);
;;;363    
;;;364    		#if 1
;;;365    		printf("UART RX : 0x%2X \r\n" , uart0Dev.RX_Buffer[0]);
;;;366    		
;;;367    		UART0_Process(uart0Dev.RX_Buffer[0]);
;;;368    		#else
;;;369    
;;;370            printf("\nUART0 Rx Received Data : %s\n",uart0Dev.RX_Buffer);
;;;371            printf("UART0 Rx RDA (Fifofull) interrupt times : %d\n",uart0Dev.RDA_Trigger_Cnt);
;;;372            printf("UART0 Rx RXTO (Timeout) interrupt times : %d\n",uart0Dev.RXTO_Trigger_Cnt);
;;;373    		#endif
;;;374    
;;;375            /* Reset UART interrupt parameter */
;;;376            UART_EnableInt(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
;;;377    		memset(&uart0Dev, 0x00, sizeof(UART_BUF_t));
;;;378    
;;;379        }
;;;380    	
;;;381    }
000038  bd70              POP      {r4-r6,pc}
                  |L11.58|
00003a  69e8              LDR      r0,[r5,#0x1c]         ;344
00003c  04c0              LSLS     r0,r0,#19             ;344
00003e  d5fb              BPL      |L11.56|
000040  f8940103          LDRB     r0,[r4,#0x103]        ;349  ; uart0Dev
000044  1c40              ADDS     r0,r0,#1              ;349
000046  f8840103          STRB     r0,[r4,#0x103]        ;349
00004a  e004              B        |L11.86|
                  |L11.76|
00004c  6828              LDR      r0,[r5,#0]            ;354
00004e  8811              LDRH     r1,[r2,#0]            ;354  ; u16UART_RX_Buffer_Index
000050  5460              STRB     r0,[r4,r1]            ;354
000052  1c49              ADDS     r1,r1,#1              ;354
000054  8011              STRH     r1,[r2,#0]            ;355
                  |L11.86|
000056  69a8              LDR      r0,[r5,#0x18]         ;352
000058  0440              LSLS     r0,r0,#17             ;352
00005a  d5f7              BPL      |L11.76|
00005c  6868              LDR      r0,[r5,#4]            ;359
00005e  f0200011          BIC      r0,r0,#0x11           ;359
000062  6068              STR      r0,[r5,#4]            ;359
000064  8013              STRH     r3,[r2,#0]            ;360
000066  7821              LDRB     r1,[r4,#0]            ;365  ; uart0Dev
000068  a00b              ADR      r0,|L11.152|
00006a  f7fffffe          BL       __2printf
00006e  7820              LDRB     r0,[r4,#0]            ;367  ; uart0Dev
000070  f7fffffe          BL       UART0_Process
000074  2111              MOVS     r1,#0x11              ;376
000076  4628              MOV      r0,r5                 ;376
000078  f7fffffe          BL       UART_EnableInt
00007c  e8bd4070          POP      {r4-r6,lr}            ;377
000080  f44f7182          MOV      r1,#0x104             ;377
000084  4802              LDR      r0,|L11.144|
000086  f7ffbffe          B.W      __aeabi_memclr
;;;382    
                          ENDP

00008a  0000              DCW      0x0000
                  |L11.140|
                          DCD      0x40070000
                  |L11.144|
                          DCD      ||.bss||
                  |L11.148|
                          DCD      ||area_number.19||
                  |L11.152|
000098  55415254          DCB      "UART RX : 0x%2X \r\n",0
00009c  20525820
0000a0  3a203078
0000a4  25325820
0000a8  0d0a00  
0000ab  00                DCB      0

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;387    
;;;388    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;389    {
;;;390        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L12.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;391    
;;;392        /* Configure UART0 and set UART0 baud rate */
;;;393        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L12.128|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;394    
;;;395    	/* Set UART receive time-out */
;;;396    	UART_SetTimeoutCnt(UART0, RX_TIMEOUT_CNT);
000014  213c              MOVS     r1,#0x3c
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;397    
;;;398    	/* Set UART FIFO RX interrupt trigger level to 4-bytes*/
;;;399        UART0->FIFO = ((UART0->FIFO & (~UART_FIFO_RFITL_Msk)) | UART_FIFO_RFITL_4BYTES);
00001c  68a0              LDR      r0,[r4,#8]
00001e  f02000f0          BIC      r0,r0,#0xf0
000022  f0400010          ORR      r0,r0,#0x10
000026  60a0              STR      r0,[r4,#8]
;;;400    
;;;401    	/* Enable UART Interrupt - */
;;;402    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
000028  6860              LDR      r0,[r4,#4]
00002a  f6400111          MOV      r1,#0x811
00002e  4308              ORRS     r0,r0,r1
000030  6060              STR      r0,[r4,#4]
;;;403    	
;;;404    	NVIC_EnableIRQ(UART0_IRQn);
000032  2024              MOVS     r0,#0x24
000034  f7fffffe          BL       NVIC_EnableIRQ
;;;405    	
;;;406    	memset(&uart0Dev, 0x00, sizeof(UART_BUF_t));
000038  f44f7182          MOV      r1,#0x104
00003c  4811              LDR      r0,|L12.132|
00003e  f7fffffe          BL       __aeabi_memclr
                  |L12.66|
;;;407    
;;;408    	UART_WAIT_TX_EMPTY(UART0);
000042  69a0              LDR      r0,[r4,#0x18]
000044  00c0              LSLS     r0,r0,#3
000046  d5fc              BPL      |L12.66|
;;;409    	
;;;410    //	set_flag(flag_UART0_Received_Data , DISABLE);
;;;411    
;;;412    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000048  f7fffffe          BL       CLK_GetCPUFreq
00004c  4601              MOV      r1,r0
00004e  a00e              ADR      r0,|L12.136|
000050  f7fffffe          BL       __2printf
;;;413    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());	
000054  f7fffffe          BL       CLK_GetHCLKFreq
000058  4601              MOV      r1,r0
00005a  a012              ADR      r0,|L12.164|
00005c  f7fffffe          BL       __2printf
;;;414    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000060  f7fffffe          BL       CLK_GetPCLK0Freq
000064  4601              MOV      r1,r0
000066  a015              ADR      r0,|L12.188|
000068  f7fffffe          BL       __2printf
;;;415    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
00006c  f7fffffe          BL       CLK_GetPCLK1Freq
000070  4601              MOV      r1,r0
000072  e8bd4010          POP      {r4,lr}
000076  a018              ADR      r0,|L12.216|
000078  f7ffbffe          B.W      __2printf
;;;416    
;;;417    }
;;;418    
                          ENDP

                  |L12.124|
                          DCD      0x04000010
                  |L12.128|
                          DCD      0x40070000
                  |L12.132|
                          DCD      ||.bss||
                  |L12.136|
000088  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
00008c  4b5f4765
000090  74435055
000094  46726571
000098  203a2025
00009c  38640d0a
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L12.164|
0000a4  434c4b5f          DCB      "CLK_GetHCLKFreq : %8d\r\n",0
0000a8  47657448
0000ac  434c4b46
0000b0  72657120
0000b4  3a202538
0000b8  640d0a00
                  |L12.188|
0000bc  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000c0  47657450
0000c4  434c4b30
0000c8  46726571
0000cc  203a2025
0000d0  38640d0a
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L12.216|
0000d8  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000dc  47657450
0000e0  434c4b31
0000e4  46726571
0000e8  203a2025
0000ec  38640d0a
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0

                          AREA ||i.UART0_Process||, CODE, READONLY, ALIGN=2

                  UART0_Process PROC
;;;272    
;;;273    void UART0_Process(uint8_t rx)
000000  491a              LDR      r1,|L13.108|
;;;274    {
;;;275    	switch(rx)
000002  2835              CMP      r0,#0x35
000004  d029              BEQ      |L13.90|
000006  dc0a              BGT      |L13.30|
000008  2831              CMP      r0,#0x31
00000a  d01d              BEQ      |L13.72|
00000c  2832              CMP      r0,#0x32
00000e  d01e              BEQ      |L13.78|
000010  2833              CMP      r0,#0x33
000012  d01f              BEQ      |L13.84|
000014  2834              CMP      r0,#0x34
000016  d128              BNE      |L13.106|
;;;276    	{
;;;277    		case '1':				
;;;278    			counter_target = 40000;
;;;279    			PDMA_TimerCapture_Start();
;;;280    		break;
;;;281    
;;;282    		case '2':
;;;283    			counter_target = 20000;
;;;284    			PDMA_TimerCapture_Start();
;;;285    		break;
;;;286    
;;;287    		case '3':
;;;288    			counter_target = 10000;
;;;289    			PDMA_TimerCapture_Start();
;;;290    		break;	
;;;291    		
;;;292    		case '4':
;;;293    			counter_target = 1000;
000018  f44f707a          MOV      r0,#0x3e8
;;;294    			PDMA_TimerCapture_Start();
;;;295    		break;	
00001c  e022              B        |L13.100|
                  |L13.30|
00001e  2836              CMP      r0,#0x36              ;275
000020  d01d              BEQ      |L13.94|
000022  2837              CMP      r0,#0x37              ;275
000024  d01d              BEQ      |L13.98|
000026  285a              CMP      r0,#0x5a              ;275
000028  d001              BEQ      |L13.46|
00002a  287a              CMP      r0,#0x7a              ;275
00002c  d11d              BNE      |L13.106|
                  |L13.46|
00002e  f3bf8f4f          DSB                            ;275
000032  480f              LDR      r0,|L13.112|
000034  6801              LDR      r1,[r0,#0]            ;275
000036  4a0f              LDR      r2,|L13.116|
000038  f40161e0          AND      r1,r1,#0x700          ;275
00003c  4311              ORRS     r1,r1,r2              ;275
00003e  6001              STR      r1,[r0,#0]            ;275
000040  f3bf8f4f          DSB                            ;275
                  |L13.68|
000044  bf00              NOP                            ;275
000046  e7fd              B        |L13.68|
                  |L13.72|
000048  f6494040          MOV      r0,#0x9c40            ;278
00004c  e00a              B        |L13.100|
                  |L13.78|
00004e  f6446020          MOV      r0,#0x4e20            ;283
000052  e007              B        |L13.100|
                  |L13.84|
000054  f2427010          MOV      r0,#0x2710            ;288
000058  e004              B        |L13.100|
                  |L13.90|
;;;296    
;;;297    		case '5':
;;;298    			counter_target = 40;
00005a  2028              MOVS     r0,#0x28
;;;299    			PDMA_TimerCapture_Start();
;;;300    		break;	
00005c  e002              B        |L13.100|
                  |L13.94|
;;;301    
;;;302    		case '6':
;;;303    			counter_target = 20;
00005e  2014              MOVS     r0,#0x14
;;;304    			PDMA_TimerCapture_Start();
;;;305    		break;	
000060  e000              B        |L13.100|
                  |L13.98|
;;;306    
;;;307    		case '7':
;;;308    			counter_target = 10;
000062  200a              MOVS     r0,#0xa
                  |L13.100|
;;;309    			PDMA_TimerCapture_Start();
000064  6088              STR      r0,[r1,#8]  ; counter_target
000066  f7ffbffe          B.W      PDMA_TimerCapture_Start
                  |L13.106|
;;;310    		break;	
;;;311    
;;;312    		case 'Z':
;;;313    		case 'z':
;;;314    			NVIC_SystemReset();
;;;315    		break;
;;;316    		
;;;317    	}
;;;318    	
;;;319    }
00006a  4770              BX       lr
;;;320    
                          ENDP

                  |L13.108|
                          DCD      ||area_number.19||
                  |L13.112|
                          DCD      0xe000ed0c
                  |L13.116|
                          DCD      0x05fa0004

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;487    
;;;488    int main()
000000  f7fffffe          BL       SYS_Init
;;;489    {
;;;490        SYS_Init();
;;;491    	
;;;492        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;493    	
;;;494    	LED_Init();
000008  f7fffffe          BL       LED_Init
;;;495    	
;;;496    	TIMER3_Init();
00000c  f7fffffe          BL       TIMER3_Init
;;;497    
;;;498    	PDMA_TimerCapture_Init();	//PB15 : TM0_EXT
000010  f7fffffe          BL       PDMA_TimerCapture_Init
                  |L14.20|
;;;499    	
;;;500        /* Got no where to go, just loop forever */
;;;501        while(1)
000014  e7fe              B        |L14.20|
;;;502        {
;;;503    		
;;;504        }
;;;505    
;;;506    }
;;;507    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  uart0Dev
                          %        260

                          AREA ||.data||, DATA, ALIGN=2

                  BitFlag
                          DCD      0x00000000

                          AREA ||area_number.19||, DATA, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.data||
                  u16UART_RX_Buffer_Index
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  g_au32CAPValue
                          DCD      0x00000000
                  counter_target
                          DCD      0x00000042
                  u32Temp
                          DCD      0x00000000
                  ||CNT||
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____RRX|
#line 587
|__asm___6_main_c_BitFlag____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
